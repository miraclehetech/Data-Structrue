/********************************************************************************************************
Copyright: wuyong
Author: wuyong
Date: 2018-05-16
Description:本例程提供了C++的STL常用数据结构及其算法的使用范例，为面试笔试编程题提供便利
*********************************************************************************************************/

#include <iostream>  
/*************************************************顺序容器***********************************************/
#include <string> //和vector是一样的，支持快速随机访问，在尾部之外的其他的位置插入都很慢
#include <vector> //可变大小数组，支持快速随机访问，在尾部之外的其它位置插入或者删除元素可能很慢

#include <list>   //双向链表，只支持双向顺序访问，在list中的任意位置插入和删除都很快

//forward_list单向链表设计目标是达到与手写单向链表相当的性能。
#include <forward_list>  //单向链表，只支持单向顺序访问，在链表任意位置插入和删除都很快,是c++11新加的标准

//在queue的中间位置插入或者删除元素代价都很高
#include <deque>  //双端队列，支持快速随机访问（肯定是顺序存储式队列），从头尾位置处插入和删除速度很快

//与内置数组相比，更加安全和方便；
#include <array>  //固定数组大小，支持快速，不能添加或者删除元素，是c++11新加的标准，支持对象赋值或者拷贝操作

//是一种容器适配器实现的栈结构
#include <stack> //栈结构，支持栈顶的快速进栈出栈操作，在栈的其他部位不可操作。
/*************************************************顺序容器***********************************************/

/*************************************************关联容器***********************************************/
#include <map> 
#include <set>
/*************************************************关联容器***********************************************/


/*************************************************无序容器***********************************************/

/*************************************************无序容器***********************************************/

/*----------------------------------------容器所共同支持的操作--------------------------------------------
1）类型别名
	1. iterator/const_iterator/size_type/difference_type/reference/const_reference

2）构造函数
	1. C c         //调用默认构造函数，无参
	2. C c1(c2)    //调用复制构造函数，有参，可合成
	3. C c(b, e)   //调用构造函数，带参，迭代器b,e指向的容器范围进行初始化构造
	4. C c{a, b, c, ......} //列表初始化构造，带参构造

3）赋值与swap
	c1 = c2
	c1 = {a, b, c, ......}
	a.swap(b)     //成员函数版的交换函数
	swap(a, b)    //非成员函数版的交换函数

4）大小
	1. c.size()   //求容器大小，
	2. c.max_size() //容器最多可保存的数据
	3. c.empty()    //返回容器是否为空

5）添加删除元素
	1. c.insert(args)  //插入元素
	2. c.emplace(inits)  //使用inits构造c中的一个元素
	3. c.erase(args)    //删除元素

6）获取迭代器
	1. c.bengin() c.end()
	2. c.cbegin(), c.cend()
	反向迭代器的成员
	reverse_iterator
	const_reverse_interator
	3. c.rbegin(), c.rend()
	4. c.crbegin(), c.crend()
-----------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------选择顺序容器的准则：-------------------------------------------

	1）若要求支持随机访问,vector queue
	2）程序要求在中间插入或者删除元素，则选择使用list 或者forward_list
	3）如果程序只会在头部或者尾部插入删除数据，则选择使用queue
	4）如果不知道选择哪种容器，则在程序中只使用list和vector容器，并且只使用迭代器而不使用下标操作
-----------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------容器的定义及初始化--------------------------------------------
C c          默认构造函数，若c是个array，则执行默认初始化，若是vector等则是空容器
C c1(c2)     c1初始化为c2的拷贝，必须是同种类型，且保存的相同的元素类型，若是array，两者还必须是相同的大小
C c1 = c2    同上

C c{a, b, c,...}    对于array，列表中的元素必须少于array的大小
C c = {a, b, c,...}

C c(b, e)           c初始化为迭代器b,e指定范围中元素的拷贝

//只有顺序容器才支持的操作：
C seq(n)    seq包含n个元素,这些元素进行了值初始化
C seq(n, t) seq包含n个初始化为值t的元素

//关于array类型：
array<int, 40> 
-----------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------赋值和swap()--------------------------------------------
c1 = c2            c2向c1拷贝

c = {a, b, c,...}  列表赋值， 而array不适用，因为array没有定义隐式转换的构造函数？
swap(c1, c2)       交换两个容器的元素
c1.wap(c2)         同上

//assign 操作不适合关联容器和array
seq.assign(b, e)   使用迭代器b，e替换容器中的元素
seq.assign(il)     使用列表进行复制
seq.assign(n, t)   使用n个值为t的元素。

//使用swap()       交换两个容器的值，不对元素进行拷贝工作，所以速度很快，除array以外
                   统一使用非成员swap(）是一个很好的选择
vector<string> svec1(10);
vector<string> svec2(20);        
swap(svec1, svec2);         
-----------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------容器大小操作-----------------------------------------------
> < == : 比和string字符串的比较一样的，只有容器的元素定义了关系运算符，才可以比较容器之间的大小
size()     返回容器中元素的个数
empty()    容器是否为空
max_size() 该类型容器最大容纳的元素的个数
           //forward_list不支持size()操作，原因肯定是因为要去手写单向链表一致
-----------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------顺序容器操作-----------------------------------------------

//forward_list   有自己专门的insert和emplace,不支持push_back和emplace_back, vector/string不支持push_front
				 以及emplace_front,虽然有些容器支持,但是对于insert(begin,...)没有限制

c.push_back(t)         在c的尾部创建t或者args创建的元素，返回void
c.emplace_back(args) 

c.push_front(t)        在c的开头创建t或者args创建的元素，返回void
c.emplace_front(t)

c.insert(p, n, t)      在迭代器p之前插入n个值为t的元素，返回新添加的第一个元素的迭代器，若n为0，则返回p
c.insert(p, b, e)      将迭代器b, e指向的元素之前插入到p所指向新添加元素之前，返回新添加第一个元素的迭代器
//insert 是按顺序向后插入的，比如{0, 1, 2}的begin插入{3，4，5}是{3, 4, 5, 0, 1, 2}
//向一个vector/string/deque中插入元素会使所有指向容器的迭代器、引用、指针失效。
//当我们使用一个对象来初始化容器时，或者将元素插入容器中，实际上放入容器的是其对象值的一个拷贝，两者并无关联

//vector和string不支持push_front()操作，而list、forward_list、deque支持push_front()操作;push_front是一种倒序的结果
//emplace_back emplace emplace_front 是在内存空间里直接构造对象，而不是拷贝。 emplace_back(args)

*************************************************************************************************************
访问元素，除了forward_list 每一个容器都提供了c.front(),以及c.back()成员，用以返回容器的首尾元素的引用
at和下标操作只适合string vector deque array  如果越界，则会爆出out_of _range错误

*************************************************************************************************************
以下操作不适合array，因为这些操作会改变容器的大小，不适于array
c.pop_back()   //删除c中的尾元素,若c为空则函数行为未定义
c.pop_front()  //删除队头元素，若c为空，则函数未定义

c.erase(p)     //删除迭代器所指的元素，返回一个指向被删除元素之后的元素的迭代器，若p指向最后一个元素，则返回
               //尾后迭代器，
c.erase(p, e)  //删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后的元素的迭代器，若e本身也是
               //最后一个元素，那么也返回尾后迭代器,

c.clear()     //删除所有的元素，

//PS：删除deque除首尾之外的所有元素都会值得所有迭代器，引用或者指针失效，指向vector以及string的删除点之后位置的
迭代器、引用、指针失效。

**************************************************************************************************************
forward_list特有的操作：forward_list<int >lst
lst.before_begin()
lst.cbefore_begin()  返回首前迭代器

lst.insert_after(p, t) 在迭代器p之后插入为值t的对象
lst.insert_after(p, n, t) n个值为t的对象 返回最后一个插入的元素的迭代器，
lst.insert_after(p, b, e) n个值为t的对象 返回最后一个插入的元素的迭代器，
lst.insert_after(p, il)   n个值为t的对象 返回最后一个插入的元素的迭代器，
emplace_after(p, args) 在p之后创建元素

lst.erase_after(p) 删除p之后的元素,返回一个被删除元素之后的元素的迭代器
lst.erase_after(b, e) 删除[p, e)的元素,返回最后一个被删除元素之后的元素的迭代器

***********************************************************************************************************
//resize()      不适合array
c.resize()      调整c的大小为c个元素，若不足，则补足
c.resize(n, t)  略

***********************************************************************************************************
c.capacity()    返回在不扩张内存的情况下可以容纳多少元素。
c.reserve()     分配至少能容纳n个元素的内存空间
c.size()        容器中有多少元素
-----------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------额外的string构造方法-----------------------------------------------
string s(cp, n)     s是cp指向数组中前n个字符的拷贝，此数组至少应该包含n个字符
string s(s2, pos2)  s是s2从下标pos2开始的拷贝，
string s(s2, pos2, len2) s是s2从下标pos2开始，长度为len2的拷贝

s.substr(pos = 0, n = s.size() - pos)    //返回一个string 包含从pos开始的n个字符的拷贝

string s("hello world");
string s2 = s.substr(0, 5);      //s2 = hello
string s3 = s.substr(6);         //s3 = world
string s4 = s.substr(6, 11);     //s4 = world
string s5 = s.substr(12);        //抛出一个out_of_range

//除了普通的insert()和erase()操作，string还有以下的重载版本，都是在pos之前插入或者删除，字符串下标是从0开始的
//string还提供了两个额外的成员append(),replace()，append()是在string末尾加入的一种形式，而replace是调用erase()和
//insert()的简写形式

s.insert(pos, args)   //在pos之前插入args指定的字符，pos是个下标或者是一个迭代器，接受下标的版本返回一个指向s的
                        引用,接受迭代器的版本返回指向第一个插入字符的迭代器

s.erase(pos, len)    //删除从pos处开始的len个字符，如果len省略则删除pos开始的所有字符，返回一个指向s的引用

s.replace(range, args)  //删除range内的元素，替换为args的元素，args可以是一个下标加一个长度，或者一对迭代器，返回
                          返回一个指向s的引用
s.append(args)          //将args加入到s的尾部，返回一个指向s的引用

s.assign(args)          //将s中的字符替换为args字符，返回一个引用

***************************************************************************************************************
string的搜索函数：
(1) s.find(args)          //查找s中第一次出现的位置,并返回子串在主串中第一个字符的下标
(2) s.rfind(args)         //查找最后一个...
(3) s.find_first_of(args) //在s中查找args中任何一个字符的第一次出现的位置，
(4) s.find_last_of(args)  //在s中查找args中任何一个字符最后一次出现的位置。
(5) s.find_first_not_of(args)   //在s中查找第一个不在args中的字符
(6) s.find_last_not_of(args)    //查找最后一个不在args中的字符

(1) args必须是以下的形式：
（c, pos）   从s中位置pos开始查找字符c，pos默认0。
（s2, pos）  从s中位置pos开始查找字符串s2，pos默认0。
（cp, pos）  从s中位置pos开始查找cp指向的以空字符结尾的C风格字符串，pos默认为0
（cp, pos, n）  从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值

**************************************************************************************************************
compare函数：这与C标准库，提供的strcmp很相似；
（1）s.compare(s2)  //比较s和s2
（2）s.compare(pos1, n1, s2) //将pos1开始的长度为n1的字符串和s2进行比较
（3）s.compare(pos1, n1, s2, pos2, n2)   
（4) s.compare(cp)  //比较s与cp指向的以空格结尾的字符数组
-----------------------------------------------------------------------------------------------------------*/

/*------------------------------------------------容器适配器-------------------------------------------------
//除了string vector list forword_list deque array等顺序容器之外，还定义了queue stack priority_queue等适配器
（1）stack      //栈，先入后出结构，
	（1）pop()
	（2）top()
	（3）push()
	（4）empty()
（2）queue  //队列，不是双端队列，但是是基于deque实现的，priority_queue是基于vector实现的
	（1）q.pop()
	（2）q.top()
	（3）q.front()
	（4）q.back()
	（5）q.top()
-----------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------关联容器--------------------------------------------------
//关联容器支持高效的关键字查找和访问，主要有map和set两种。再冠以multi以及unorder就一共有八种关联容器
关联容器：有三个比较关键的类型key_value mapped_type value_type  //
有两个数据成员first、second 两个，first 是关键字，second是值，进行下标运算的时候，若元素不在容器内，那么容器创建新键值对，
并且值为0；需要手动加加；
而set的find()函数，找到了返回该元素迭代器，找不到返回尾后迭代器；
//关联容器的关键值一定要有比较运算符，因为插入容器的元素默认是按字典序排序的；
//关联容器迭代器：map的关键值是const 类型 而set的迭代器就是const类型，且迭代器支持++操作
**********************************************************************************************************
pair类型:
	(1)pair<t1, t2>p()
	(2)pair<t1, t2>p = {v1, v2};
	(3)make_pair(v1, v2)
**********************************************************************************************************
(1)插入操作：
	c.insert(v) 对于map set 当v不在容器中才执行插入操作
	c.insert(b, e) 
	c.insert(il)   
//插入单个元素返回一个pair类型，pair的second成员是一个bool值，返回是否插入成功则返回true，first无论何时都指向value例如
	std::map<std::string, int>word_count;
	std::string tmp;
	while (std::cin >> tmp)
	{
		auto ret = word_count.insert({ tmp, 1 });
		if (!ret.second)
			//++word_count[tmp];
			++ret.first->second;
	}
	auto begin = word_count.begin();
	while (begin != word_count.end())
	{
		std::cout << begin->first << ":" << begin->second << std::endl;
		++begin;
	}
(2)而向multimap以及multiset中插入元素，犯规一个指向新值的迭代器，没有second，因为总会新插入一个迭代器
(3)map的下标操作：
	（1）c[k]      //下标操作会返回一个mapped_type 而解引用操作会返回一个value_type
	（2）c.at(k)  
(4)find()操作
	例：if(word_count.find("foobar") == word_count.end())
	但是如果是一个multimap或者multiset的时候，由于具有相同关键字的连续存储，则需要先使用count获取数量，在使用
	find()函数获取第一个元素，然后在使用循环挨个访问；
	可以使用面向迭代器的解决方法：
	lower_bound() upper_bound()来解决，前者指向第一个匹配的关键字，后者最后匹配的关键字，也可以只用equal_range来实现
	若存在返回一个pair，first指向第一个，second指向最后一个。若不存在，则都返回指向可以插入的位置
***************************************************************************************************************

-----------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------额外的string构造方法--------------------------------------
给出string vector array list forward_list deque queue stack map multimap set multiset tuple bitset所支持的操作以及范例
-----------------------------------------------------------------------------------------------------------*/

#include "myString.h"
#include "myVector.h"
#include "myList.h"
#include "myForward_list.h"
#include "myDeque.h"
#include "myArray.h"
#include "myMap.h"
#include "mySet.h"
#include "myAlgorithm.h"
#include "myStackAndQueue.h"
#include "tupleAndBitset.h"

int main()
{
	myStringTest();
	myVectorTest();
	myListTest();
	myForward_listTest();
	myDequeTest();
	myArrayTest();
	myMapTest();
	myMapTest();
	mySetTest();

	myStackTest();
	myQueueTest();
	tupleAndBitsetTest();
	myAlgorithmTest();


	system("pause");
	return 0;

}
















